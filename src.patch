diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2017-05-15 13:09:52.349961582 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2017-05-30 05:34:07.726665412 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Random;
@@ -20,7 +21,8 @@
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
     private boolean g = true;
-    private final Set<BlockPosition> B = Sets.newHashSet();
+    //private final Set<BlockPosition> B = Sets.newHashSet();
+    private final Set<BlockPosition> B = Collections.synchronizedSet(Sets.newHashSet());
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -109,18 +111,20 @@
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.B);
+        synchronized (this.B) {
+            ArrayList arraylist = Lists.newArrayList(this.B);
 
-        this.B.clear();
-        Iterator iterator = arraylist.iterator();
+            this.B.clear();
+            Iterator iterator = arraylist.iterator();
 
-        while (iterator.hasNext()) {
-            BlockPosition blockposition1 = (BlockPosition) iterator.next();
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
 
-            world.applyPhysics(blockposition1, this, false);
-        }
+                world.applyPhysics(blockposition1, this, false);
+            }
 
-        return iblockdata;
+            return iblockdata;
+        }
     }
 
     private IBlockData a(World world, BlockPosition blockposition, BlockPosition blockposition1, IBlockData iblockdata) {
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2017-05-15 13:09:52.500961596 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2017-05-30 05:34:07.855665425 +0800
@@ -15,6 +15,8 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
+import java.util.stream.IntStream;
 import org.bukkit.Server; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +34,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices;//hose
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -80,17 +83,20 @@
         this.g = new byte[256];
         this.h = new int[256];
         this.i = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
+        //this.tileEntities = Maps.newHashMap();
+        this.tileEntities = Maps.newConcurrentMap();//hose
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new Queue[16]);//hose
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Queues.newConcurrentLinkedQueue();//hose
         }
 
         Arrays.fill(this.h, -999);
@@ -744,11 +750,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j];
 
             this.world.a((Collection) entityslice);
         }
@@ -777,7 +785,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;//hose        
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -1288,8 +1297,12 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
-        return this.entitySlices;
+    public List<Entity>[] getEntitySlices() {//hose
+        List<Entity>[] al = (List[]) (new List[16]);
+        IntStream.range(0, 16).forEach(c -> {
+            al[c] = Lists.newArrayList(this.entitySlices[c]);
+        });
+        return al;
     }
 
     public boolean isDone() {
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2017-05-15 13:09:52.463961593 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2017-05-30 05:34:07.858665425 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -10,6 +11,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -23,10 +25,12 @@
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet();
+    //public final Set<Long> unloadQueue = Sets.newHashSet();
+    public final Set<Long> unloadQueue = Sets.newConcurrentHashSet();//hose
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap();//hose
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
@@ -47,14 +51,16 @@
 
     }
 
-    public void b() {
+    public void b() {//hose
+        this.chunks.entrySet().forEach(map -> this.unload(map.getValue()));
+        /*
         ObjectIterator objectiterator = this.chunks.values().iterator();
 
         while (objectiterator.hasNext()) {
             Chunk chunk = (Chunk) objectiterator.next();
 
             this.unload(chunk);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2017-05-15 13:09:52.703961615 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2017-05-30 05:34:08.126665450 +0800
@@ -12,6 +12,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.RecursiveTask;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -586,6 +587,18 @@
                 }
             }
 
+            double[] cor = new double[3];
+            cor[0] = d0;
+            cor[1] = d1;
+            cor[2] = d2;
+            move mvt = new move(cor, this, enummovetype);
+            mvt.fork();
+            cor = (double[]) mvt.join();
+            d0 = cor[0];
+            d1 = cor[1];
+            d2 = cor[2];
+            /*
+            long mst = System.nanoTime();
             this.world.methodProfiler.a("move");
             double d4 = this.locX;
             double d5 = this.locY;
@@ -778,8 +791,12 @@
                     this.a(axisalignedbb1);
                 }
             }
-
+            
             this.world.methodProfiler.b();
+            long met = System.nanoTime();
+            System.out.println("move time: "+(met-mst)+"ns.");
+            
+            //long rst = System.nanoTime();
             this.world.methodProfiler.a("rest");
             this.recalcPosition();
             this.positionChanged = d7 != d0 || d9 != d2;
@@ -873,20 +890,6 @@
                 }
             }
 
-            // CraftBukkit start - Move to the top of the method
-            /*
-            try {
-                this.checkBlockCollisions();
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
-
-                this.appendEntityCrashDetails(crashreportsystemdetails);
-                throw new ReportedException(crashreport);
-            }
-            */
-            // CraftBukkit end
-
             boolean flag1 = this.ai();
 
             if (this.world.e(this.getBoundingBox().shrink(0.001D))) {
@@ -914,6 +917,8 @@
             }
 
             this.world.methodProfiler.b();
+            //long ret = System.nanoTime();
+            //System.out.println("rest time: "+(ret-rst)+"ns.");*/
         }
         org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
@@ -2790,4 +2795,351 @@
     public int getMaxFireTicks() {
         return 1;
     }
+    
+    public class move extends RecursiveTask {
+        double[] cor = new double[3];
+        Entity ent;
+        EnumMoveType enummovetype;
+        
+        public move (double[] cor, Entity ent, EnumMoveType enummovetype) {
+            this.cor = cor;
+            this.ent = ent;
+            this.enummovetype = enummovetype;
+        }
+        
+        
+        @Override
+        protected double[] compute() {
+            long mst = System.nanoTime();
+            world.methodProfiler.a("move");
+            double d4 = locX;
+            double d5 = locY;
+            double d6 = locZ;
+            double d0 = this.cor[0];
+            double d1 = this.cor[1];
+            double d2 = this.cor[2];
+            
+
+            if (E) {
+                E = false;
+                d0 *= 0.25D;
+                d1 *= 0.05000000074505806D;
+                d2 *= 0.25D;
+                motX = 0.0D;
+                motY = 0.0D;
+                motZ = 0.0D;
+            }
+
+            double d7 = d0;
+            double d8 = d1;
+            double d9 = d2;
+
+            if ((enummovetype == EnumMoveType.SELF || enummovetype == EnumMoveType.PLAYER) && onGround && isSneaking() && ent instanceof EntityHuman) {
+                for (double d10 = 0.05D; d0 != 0.0D && world.getCubes(ent, getBoundingBox().d(d0, (double) (-P), 0.0D)).isEmpty(); d7 = d0) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+                }
+
+                for (; d2 != 0.0D && world.getCubes(ent, getBoundingBox().d(0.0D, (double) (-P), d2)).isEmpty(); d9 = d2) {
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+
+                for (; d0 != 0.0D && d2 != 0.0D && world.getCubes(ent, getBoundingBox().d(d0, (double) (-P), d2)).isEmpty(); d9 = d2) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+
+                    d7 = d0;
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+            }
+
+            List list = world.getCubes(ent, getBoundingBox().b(d0, d1, d2));
+            AxisAlignedBB axisalignedbb = getBoundingBox();
+            int k;
+            int l;
+
+            if (d1 != 0.0D) {
+                k = 0;
+
+                for (l = list.size(); k < l; ++k) {
+                    d1 = ((AxisAlignedBB) list.get(k)).b(getBoundingBox(), d1);
+                }
+
+                a(getBoundingBox().d(0.0D, d1, 0.0D));
+            }
+
+            if (d0 != 0.0D) {
+                k = 0;
+
+                for (l = list.size(); k < l; ++k) {
+                    d0 = ((AxisAlignedBB) list.get(k)).a(getBoundingBox(), d0);
+                }
+
+                if (d0 != 0.0D) {
+                    a(getBoundingBox().d(d0, 0.0D, 0.0D));
+                }
+            }
+
+            if (d2 != 0.0D) {
+                k = 0;
+
+                for (l = list.size(); k < l; ++k) {
+                    d2 = ((AxisAlignedBB) list.get(k)).c(getBoundingBox(), d2);
+                }
+
+                if (d2 != 0.0D) {
+                    a(getBoundingBox().d(0.0D, 0.0D, d2));
+                }
+            }
+
+            boolean flag = onGround || d1 != d8 && d1 < 0.0D; // CraftBukkit - decompile error
+            double d11;
+
+            if (P > 0.0F && flag && (d7 != d0 || d9 != d2)) {
+                double d12 = d0;
+                double d13 = d1;
+                double d14 = d2;
+                AxisAlignedBB axisalignedbb1 = getBoundingBox();
+
+                a(axisalignedbb);
+                d1 = (double) P;
+                List list1 = world.getCubes(ent, getBoundingBox().b(d7, d1, d9));
+                AxisAlignedBB axisalignedbb2 = getBoundingBox();
+                AxisAlignedBB axisalignedbb3 = axisalignedbb2.b(d7, 0.0D, d9);
+
+                d11 = d1;
+                int i1 = 0;
+
+                for (int j1 = list1.size(); i1 < j1; ++i1) {
+                    d11 = ((AxisAlignedBB) list1.get(i1)).b(axisalignedbb3, d11);
+                }
+
+                axisalignedbb2 = axisalignedbb2.d(0.0D, d11, 0.0D);
+                double d15 = d7;
+                int k1 = 0;
+
+                for (int l1 = list1.size(); k1 < l1; ++k1) {
+                    d15 = ((AxisAlignedBB) list1.get(k1)).a(axisalignedbb2, d15);
+                }
+
+                axisalignedbb2 = axisalignedbb2.d(d15, 0.0D, 0.0D);
+                double d16 = d9;
+                int i2 = 0;
+
+                for (int j2 = list1.size(); i2 < j2; ++i2) {
+                    d16 = ((AxisAlignedBB) list1.get(i2)).c(axisalignedbb2, d16);
+                }
+
+                axisalignedbb2 = axisalignedbb2.d(0.0D, 0.0D, d16);
+                AxisAlignedBB axisalignedbb4 = getBoundingBox();
+                double d17 = d1;
+                int k2 = 0;
+
+                for (int l2 = list1.size(); k2 < l2; ++k2) {
+                    d17 = ((AxisAlignedBB) list1.get(k2)).b(axisalignedbb4, d17);
+                }
+
+                axisalignedbb4 = axisalignedbb4.d(0.0D, d17, 0.0D);
+                double d18 = d7;
+                int i3 = 0;
+
+                for (int j3 = list1.size(); i3 < j3; ++i3) {
+                    d18 = ((AxisAlignedBB) list1.get(i3)).a(axisalignedbb4, d18);
+                }
+
+                axisalignedbb4 = axisalignedbb4.d(d18, 0.0D, 0.0D);
+                double d19 = d9;
+                int k3 = 0;
+
+                for (int l3 = list1.size(); k3 < l3; ++k3) {
+                    d19 = ((AxisAlignedBB) list1.get(k3)).c(axisalignedbb4, d19);
+                }
+
+                axisalignedbb4 = axisalignedbb4.d(0.0D, 0.0D, d19);
+                double d20 = d15 * d15 + d16 * d16;
+                double d21 = d18 * d18 + d19 * d19;
+
+                if (d20 > d21) {
+                    d0 = d15;
+                    d2 = d16;
+                    d1 = -d11;
+                    a(axisalignedbb2);
+                } else {
+                    d0 = d18;
+                    d2 = d19;
+                    d1 = -d17;
+                    a(axisalignedbb4);
+                }
+
+                int i4 = 0;
+
+                for (int j4 = list1.size(); i4 < j4; ++i4) {
+                    d1 = ((AxisAlignedBB) list1.get(i4)).b(getBoundingBox(), d1);
+                }
+
+                a(getBoundingBox().d(0.0D, d1, 0.0D));
+                if (d12 * d12 + d14 * d14 >= d0 * d0 + d2 * d2) {
+                    d0 = d12;
+                    d1 = d13;
+                    d2 = d14;
+                    a(axisalignedbb1);
+                }
+            }
+            
+            world.methodProfiler.b();
+                        
+            //long rst = System.nanoTime();
+            world.methodProfiler.a("rest");
+            recalcPosition();
+            positionChanged = d7 != d0 || d9 != d2;
+            B = d1 != d8; // CraftBukkit - decompile error
+            onGround = B && d8 < 0.0D;
+            C = positionChanged || B;
+            l = MathHelper.floor(locX);
+            int k4 = MathHelper.floor(locY - 0.20000000298023224D);
+            int l4 = MathHelper.floor(locZ);
+            BlockPosition blockposition = new BlockPosition(l, k4, l4);
+            IBlockData iblockdata = world.getType(blockposition);
+
+            if (iblockdata.getMaterial() == Material.AIR) {
+                BlockPosition blockposition1 = blockposition.down();
+                IBlockData iblockdata1 = world.getType(blockposition1);
+                Block block = iblockdata1.getBlock();
+
+                if (block instanceof BlockFence || block instanceof BlockCobbleWall || block instanceof BlockFenceGate) {
+                    iblockdata = iblockdata1;
+                    blockposition = blockposition1;
+                }
+            }
+
+            a(d1, onGround, iblockdata, blockposition);
+            if (d7 != d0) {
+                motX = 0.0D;
+            }
+
+            if (d9 != d2) {
+                motZ = 0.0D;
+            }
+
+            Block block1 = iblockdata.getBlock();
+
+            if (d8 != d1) {
+                block1.a(world, ent);
+            }
+
+            // CraftBukkit start
+            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) getBukkitEntity();
+                org.bukkit.block.Block bl = world.getWorld().getBlockAt(MathHelper.floor(locX), MathHelper.floor(locY), MathHelper.floor(locZ));
+
+                if (d6 > d0) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (d6 < d0) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (d8 > d2) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (d8 < d2) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                if (bl.getType() != org.bukkit.Material.AIR) {
+                    VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                    world.getServer().getPluginManager().callEvent(event);
+                }
+            }
+            // CraftBukkit end            // CraftBukkit end
+
+            if (playStepSound() && (!onGround || !isSneaking() || !(ent instanceof EntityHuman)) && !isPassenger()) {
+                double d22 = locX - d4;
+                double d23 = locY - d5;
+
+                d11 = locZ - d6;
+                if (block1 != Blocks.LADDER) {
+                    d23 = 0.0D;
+                }
+
+                if (block1 != null && onGround) {
+                    block1.stepOn(world, blockposition, ent);
+                }
+
+                J = (float) ((double) J + (double) MathHelper.sqrt(d22 * d22 + d11 * d11) * 0.6D);
+                K = (float) ((double) K + (double) MathHelper.sqrt(d22 * d22 + d23 * d23 + d11 * d11) * 0.6D);
+                if (K > (float) ax && iblockdata.getMaterial() != Material.AIR) {
+                    ax = (int) K + 1;
+                    if (isInWater()) {
+                        Entity entity = isVehicle() && bw() != null ? bw() : ent;
+                        float f = entity == ent ? 0.35F : 0.4F;
+                        float f1 = MathHelper.sqrt(entity.motX * entity.motX * 0.20000000298023224D + entity.motY * entity.motY + entity.motZ * entity.motZ * 0.20000000298023224D) * f;
+
+                        if (f1 > 1.0F) {
+                            f1 = 1.0F;
+                        }
+
+                        a(aa(), f1, 1.0F + (random.nextFloat() - random.nextFloat()) * 0.4F);
+                    } else {
+                        a(blockposition, block1);
+                    }
+                }
+            }
+
+            boolean flag1 = ai();
+
+            if (world.e(getBoundingBox().shrink(0.001D))) {
+                burn(1);
+                if (!flag1) {
+                    ++fireTicks;
+                    if (fireTicks == 0) {
+                        // CraftBukkit start
+                        EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            setOnFire(event.getDuration());
+                        }
+                        // CraftBukkit end
+                    }
+                }
+            } else if (fireTicks <= 0) {
+                fireTicks = -getMaxFireTicks();
+            }
+
+            if (flag1 && isBurning()) {
+                a(SoundEffects.bQ, 0.7F, 1.6F + (random.nextFloat() - random.nextFloat()) * 0.4F);
+                fireTicks = -getMaxFireTicks();
+            }
+
+            world.methodProfiler.b();
+            //long ret = System.nanoTime();
+            //System.out.println("rest time: "+(ret-rst)+"ns.");
+            
+            cor[0] = d0;
+            cor[1] = d1;
+            cor[2] = d2;
+            return this.cor;
+        }
+    
+    
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLightning.java src/main/java/net/minecraft/server/EntityLightning.java
--- src_origin/main/java/net/minecraft/server/EntityLightning.java	2017-05-15 13:09:52.889961633 +0800
+++ src/main/java/net/minecraft/server/EntityLightning.java	2017-05-30 05:34:08.316665468 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import java.util.List;
+import java.util.Queue;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -66,7 +67,8 @@
             // this.world.a((EntityHuman) null, this.locX, this.locY, this.locZ, SoundEffects.dv, SoundCategory.WEATHER, 10000.0F, 0.8F + this.random.nextFloat() * 0.2F);
             float pitch = 0.8F + this.random.nextFloat() * 0.2F;
             int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
-            for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.players) {
+            //for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.players) {
+            for (EntityPlayer player : (Queue<EntityPlayer>) (Queue) this.world.players) {//hose
                 double deltaX = this.locX - player.locX;
                 double deltaZ = this.locZ - player.locZ;
                 double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2017-05-15 13:09:52.942961638 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2017-05-30 05:34:08.340665470 +0800
@@ -17,6 +17,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -2061,7 +2062,13 @@
         this.bg *= 0.9F;
         this.r();
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
-        this.g(this.be, this.bf);
+        //this.g(this.be, this.bf);
+        float x = this.be;//hose
+        float y = this.bf;
+        AImove ait = new AImove(x, y);
+        ait.fork();
+        ait.join();
+        
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
@@ -2476,4 +2483,20 @@
     public boolean cK() {
         return true;
     }
+    
+    public class AImove extends RecursiveAction {
+        float x, y;
+        
+        public AImove(float x, float y) {
+            this.x = x;
+            this.y = y;
+        }
+        
+        @Override
+        protected void compute() {
+            g(this.x, this.y);
+        }
+        
+    }
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2017-05-15 13:09:52.995961643 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2017-05-30 05:34:08.410665476 +0800
@@ -14,6 +14,8 @@
 
 // CraftBukkit start
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Queues;
+import java.util.Queue;
 import org.bukkit.Bukkit;
 import org.bukkit.GameMode;
 import org.bukkit.WeatherType;
@@ -37,7 +39,8 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final Queue<Integer> removeQueue = Queues.newConcurrentLinkedQueue();//hose
     private final ServerStatisticManager bU;
     private float bV = Float.MIN_VALUE;
     private int bW = Integer.MIN_VALUE;
@@ -959,7 +962,10 @@
         this.lastSentExp = -1;
         this.lastHealthSent = -1.0F;
         this.cc = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        //this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        Queue<Integer> q2 = Queues.newConcurrentLinkedQueue();//hose
+        ((EntityPlayer) entityhuman).removeQueue.stream().forEach(eh -> q2.add(eh));//hose
+        q2.stream().forEach(eh -> this.removeQueue.add(eh));//hose
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2017-05-15 13:09:53.098961652 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2017-05-30 05:34:08.531665488 +0800
@@ -1,10 +1,12 @@
 package net.minecraft.server;
 
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -41,7 +43,8 @@
     private boolean x;
     private boolean y;
     public boolean b;
-    public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public final Set<EntityPlayer> trackedPlayers = Sets.newConcurrentHashSet();//hose
 
     public EntityTrackerEntry(Entity entity, int i, int j, int k, boolean flag) {
         this.tracker = entity;
@@ -66,7 +69,8 @@
         return this.tracker.getId();
     }
 
-    public void track(List<EntityHuman> list) {
+    //public void track(List<EntityHuman> list) {
+    public void track(Queue<EntityHuman> list) {//hose
         this.b = false;
         if (!this.isMoving || this.tracker.d(this.q, this.r, this.s) > 16.0D) {
             this.q = this.tracker.locX;
@@ -91,6 +95,18 @@
 
             if (this.a % 10 == 0 && itemstack.getItem() instanceof ItemWorldMap) { // CraftBukkit - Moved this.a % 10 logic here so item frames do not enter the other blocks
                 WorldMap worldmap = Items.FILLED_MAP.getSavedMap(itemstack, this.tracker.world);
+                this.trackedPlayers.stream().forEach(iterator -> {//hose
+                    EntityHuman entityhuman = (EntityHuman) iterator;
+                    EntityPlayer entityplayer = (EntityPlayer) entityhuman;
+
+                    worldmap.a(entityplayer, itemstack);
+                    Packet packet = Items.FILLED_MAP.a(itemstack, this.tracker.world, (EntityHuman) entityplayer);
+
+                    if (packet != null) {
+                        entityplayer.playerConnection.sendPacket(packet);
+                    }
+                });
+                /*
                 Iterator iterator = this.trackedPlayers.iterator(); // CraftBukkit
 
                 while (iterator.hasNext()) {
@@ -103,7 +119,7 @@
                     if (packet != null) {
                         entityplayer.playerConnection.sendPacket(packet);
                     }
-                }
+                }*/
             }
 
             this.d();
@@ -171,7 +187,8 @@
                         this.v = 0;
                         // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
                         if (this.tracker instanceof EntityPlayer) {
-                            this.scanPlayers(new java.util.ArrayList(this.trackedPlayers));
+                            //this.scanPlayers(new java.util.ArrayList(this.trackedPlayers));
+                            this.scanPlayers(Queues.newConcurrentLinkedQueue(this.trackedPlayers));//hose
                         }
                         // CraftBukkit end
                         this.c();
@@ -336,7 +353,8 @@
                         }
                     }
 
-                    entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    entityplayer.removeQueue.remove(this.tracker.getId());//hose
                     // CraftBukkit end
                     this.trackedPlayers.add(entityplayer);
                     Packet packet = this.e();
@@ -444,10 +462,12 @@
         return entityplayer.x().getPlayerChunkMap().a(entityplayer, this.tracker.ab, this.tracker.ad);
     }
 
-    public void scanPlayers(List<EntityHuman> list) {
-        for (int i = 0; i < list.size(); ++i) {
+    //public void scanPlayers(List<EntityHuman> list) {
+    public void scanPlayers(Queue<EntityHuman> list) {//hose
+        list.stream().forEach(pl -> this.updatePlayer((EntityPlayer) pl));
+        /*for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2017-05-15 13:09:53.090961652 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2017-05-30 05:34:08.525665487 +0800
@@ -1,9 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -12,8 +16,10 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();//hose
+    //public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();//hose
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
@@ -108,14 +114,16 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
-            if (this.trackedEntities.b(entity.getId())) {
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(entity.getId())) {//hose
                 throw new IllegalStateException("Entity is already tracked!");
             }
 
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
 
             this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);//hose
             entitytrackerentry.scanPlayers(this.world.players);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -139,7 +147,11 @@
                 }
             });
             entity.appendEntityCrashDetails(crashreportsystemdetails);
-            ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).b().appendEntityCrashDetails(crashreport.a("Entity That Is Already Tracked"));
+            try {
+                ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).b().appendEntityCrashDetails(crashreport.a("Entity That Is Already Tracked"));
+            } catch (Exception ex) {
+                this.trackedEntities.remove(entity.getId());
+            }
 
             try {
                 throw new ReportedException(crashreport);
@@ -150,7 +162,7 @@
 
     }
 
-    public void untrackEntity(Entity entity) {
+    public void untrackEntity(Entity entity) {//the problem is here //hose
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
@@ -163,8 +175,8 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.remove(entity.getId());//hose
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
             entitytrackerentry1.a();
@@ -172,7 +184,23 @@
 
     }
 
-    public void updatePlayers() {
+    public void updatePlayers() {//hose
+        Queue arraylist = Queues.newConcurrentLinkedQueue();
+        this.c.parallelStream().forEach(entitytrackerentry -> {
+            entitytrackerentry.track(this.world.players);
+            if (entitytrackerentry.b) {
+                Entity entity = entitytrackerentry.b();
+ 
+                if (entity instanceof EntityPlayer) {
+                    arraylist.add((EntityPlayer) entity);
+                }
+            }
+        });
+        
+        arraylist.parallelStream().forEach(entityplayer -> {
+            this.c.parallelStream().filter(entitytrackerentry1 -> entitytrackerentry1.b() != entityplayer).forEach(entitytrackerentry1 -> entitytrackerentry1.updatePlayer((EntityPlayer) entityplayer));
+        });
+        /*
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
 
@@ -200,7 +228,7 @@
                     entitytrackerentry1.updatePlayer(entityplayer);
                 }
             }
-        }
+        }*/
 
     }
 
@@ -236,8 +264,9 @@
         }
 
     }
-
-    public void untrackPlayer(EntityPlayer entityplayer) {
+    
+    Set<EntityTrackerEntry> remove_untrack = Sets.newConcurrentHashSet();//hose
+    public void untrackPlayer(EntityPlayer entityplayer) {//hose
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -245,7 +274,26 @@
 
             entitytrackerentry.clear(entityplayer);
         }
-
+        //remove all untrack here
+        
+        for (EntityTrackerEntry ete: this.c) {
+            int exist_count = 0;
+            try {
+                for (Entity ent:this.world.entityList) {
+                    if (ent.getId() == ete.hashCode()) {
+                        exist_count++;
+                    }
+                }
+                if (exist_count == 0) {
+                    remove_untrack.add(ete);
+                }
+            } catch (Exception ex) {
+                //
+            }
+        }
+        
+        this.c.removeAll(remove_untrack);
+        remove_untrack.clear();
     }
 
     public void a(EntityPlayer entityplayer, Chunk chunk) {
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2017-05-15 13:09:53.392961680 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2017-05-30 05:34:08.887665521 +0800
@@ -1043,8 +1043,9 @@
 
     }
 
-    public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+    public String getServerModName() {//hose
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Hose"; // Hose > Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1125,8 +1126,9 @@
         return true; // CraftBukkit
     }
 
-    public String getName() {
-        return "Server";
+    public String getName() {//hose
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2017-05-30 05:34:08.920665524 +0800
@@ -0,0 +1,289 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance f;
+    private int g;
+    private int h;
+    private Vec3D i;
+    private Vec3D j;
+    private long k;
+    private long l;
+    private double m;
+    private float n;
+    private boolean o;
+    private long p;
+    protected PathfinderAbstract e;
+    private BlockPosition q;
+    private final Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.i = Vec3D.a;
+        this.j = Vec3D.a;
+        this.n = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.f = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float h() {
+        return (float) this.f.getValue();
+    }
+
+    public boolean i() {
+        return this.o;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.p > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.a(this.q);
+                this.p = this.b.getTime();
+                this.o = false;
+            }
+        } else {
+            this.o = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.a(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            try {//hose
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = new BlockPosition(this.a);
+                int i = (int) (f + 8.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            } catch (Exception ex) {
+                this.b.getServer().getLogger().warning("Nav PathEntity a() exception:"+ex.getMessage());
+                return null;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.d();
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.h = this.g;
+                this.i = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void l() {
+        ++this.g;
+        if (this.o) {
+            this.j();
+        }
+
+        if (!this.n()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.m();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            if (!this.n()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (vec3d != null) {
+                    BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                    AxisAlignedBB axisalignedbb = this.b.getType(blockposition).d(this.b, blockposition);
+
+                    vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                    this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+                }
+            }
+        }
+    }
+
+    protected void m() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.n = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.n && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.n && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+        
+        try {//hose
+            for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+                if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                    this.c.c(j1);
+                    break;
+                }
+            }
+        } catch (Exception ex) {
+            this.b.getServer().getLogger().warning("Nav m() exception:"+ex.getMessage());
+            return;
+        }
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.g - this.h > 100) {
+            if (vec3d.distanceSquared(this.i) < 2.25D) {
+                this.o();
+            }
+
+            this.h = this.g;
+            this.i = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.j)) {
+                this.k += System.currentTimeMillis() - this.l;
+            } else {
+                this.j = vec3d1;
+                double d0 = vec3d.f(this.j);
+
+                this.m = this.a.cq() > 0.0F ? d0 / (double) this.a.cq() * 1000.0D : 0.0D;
+            }
+
+            if (this.m > 0.0D && (double) this.k > this.m * 3.0D) {
+                this.j = Vec3D.a;
+                this.k = 0L;
+                this.m = 0.0D;
+                this.o();
+            }
+
+            this.l = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean n() {
+        return this.c == null || this.c.b();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean p() {
+        return this.a.isInWater() || this.a.ao();
+    }
+
+    protected void d() {}
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/Navigation.java src/main/java/net/minecraft/server/Navigation.java
--- src_origin/main/java/net/minecraft/server/Navigation.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/Navigation.java	2017-05-30 05:34:08.913665523 +0800
@@ -0,0 +1,275 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public class Navigation extends NavigationAbstract {
+
+    private boolean f;
+
+    public Navigation(EntityInsentient entityinsentient, World world) {
+        super(entityinsentient, world);
+    }
+
+    protected Pathfinder a() {
+        this.e = new PathfinderNormal();
+        this.e.a(true);
+        return new Pathfinder(this.e);
+    }
+
+    protected boolean b() {
+        return this.a.onGround || this.g() && this.p() || this.a.isPassenger();
+    }
+
+    protected Vec3D c() {
+        return new Vec3D(this.a.locX, (double) this.r(), this.a.locZ);
+    }
+
+    public PathEntity a(BlockPosition blockposition) {
+        BlockPosition blockposition1;
+
+        if (this.b.getType(blockposition).getMaterial() == Material.AIR) {
+            for (blockposition1 = blockposition.down(); blockposition1.getY() > 0 && this.b.getType(blockposition1).getMaterial() == Material.AIR; blockposition1 = blockposition1.down()) {
+                ;
+            }
+
+            if (blockposition1.getY() > 0) {
+                return super.a(blockposition1.up());
+            }
+
+            while (blockposition1.getY() < this.b.getHeight() && this.b.getType(blockposition1).getMaterial() == Material.AIR) {
+                blockposition1 = blockposition1.up();
+            }
+
+            blockposition = blockposition1;
+        }
+
+        if (!this.b.getType(blockposition).getMaterial().isBuildable()) {
+            return super.a(blockposition);
+        } else {
+            for (blockposition1 = blockposition.up(); blockposition1.getY() < this.b.getHeight() && this.b.getType(blockposition1).getMaterial().isBuildable(); blockposition1 = blockposition1.up()) {
+                ;
+            }
+
+            return super.a(blockposition1);
+        }
+    }
+
+    public PathEntity a(Entity entity) {
+        return this.a(new BlockPosition(entity));
+    }
+
+    private int r() {
+        if (this.a.isInWater() && this.g()) {
+            int i = (int) this.a.getBoundingBox().b;
+            Block block = this.b.getType(new BlockPosition(MathHelper.floor(this.a.locX), i, MathHelper.floor(this.a.locZ))).getBlock();
+            int j = 0;
+
+            do {
+                if (block != Blocks.FLOWING_WATER && block != Blocks.WATER) {
+                    return i;
+                }
+
+                ++i;
+                block = this.b.getType(new BlockPosition(MathHelper.floor(this.a.locX), i, MathHelper.floor(this.a.locZ))).getBlock();
+                ++j;
+            } while (j <= 16);
+
+            return (int) this.a.getBoundingBox().b;
+        } else {
+            return (int) (this.a.getBoundingBox().b + 0.5D);
+        }
+    }
+
+    protected void d() {
+        super.d();
+
+        int i;
+        PathPoint pathpoint;
+        
+        for (i = 0; i < this.c.d(); ++i) {
+            try {//hose
+                pathpoint = this.c.a(i);
+                PathPoint pathpoint1 = i + 1 < this.c.d() ? this.c.a(i + 1) : null;
+                IBlockData iblockdata = this.b.getType(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+                Block block = iblockdata.getBlock();
+
+                if (block == Blocks.cauldron) {
+                    this.c.a(i, pathpoint.a(pathpoint.a, pathpoint.b + 1, pathpoint.c));
+                    if (pathpoint1 != null && pathpoint.b >= pathpoint1.b) {
+                        this.c.a(i + 1, pathpoint1.a(pathpoint1.a, pathpoint.b + 1, pathpoint1.c));
+                    }
+                }
+            } catch (Exception ex) {
+                this.b.getServer().getLogger().warning("nv d():"+ex);
+            }
+        }
+
+        if (this.f) {
+            if (this.b.h(new BlockPosition(MathHelper.floor(this.a.locX), (int) (this.a.getBoundingBox().b + 0.5D), MathHelper.floor(this.a.locZ)))) {
+                return;
+            }
+
+            for (i = 0; i < this.c.d(); ++i) {
+                pathpoint = this.c.a(i);
+                if (this.b.h(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c))) {
+                    this.c.b(i - 1);
+                    return;
+                }
+            }
+        }
+
+    }
+
+    protected boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k) {
+        int l = MathHelper.floor(vec3d.x);
+        int i1 = MathHelper.floor(vec3d.z);
+        double d0 = vec3d1.x - vec3d.x;
+        double d1 = vec3d1.z - vec3d.z;
+        double d2 = d0 * d0 + d1 * d1;
+
+        if (d2 < 1.0E-8D) {
+            return false;
+        } else {
+            double d3 = 1.0D / Math.sqrt(d2);
+
+            d0 *= d3;
+            d1 *= d3;
+            i += 2;
+            k += 2;
+            if (!this.a(l, (int) vec3d.y, i1, i, j, k, vec3d, d0, d1)) {
+                return false;
+            } else {
+                i -= 2;
+                k -= 2;
+                double d4 = 1.0D / Math.abs(d0);
+                double d5 = 1.0D / Math.abs(d1);
+                double d6 = (double) l - vec3d.x;
+                double d7 = (double) i1 - vec3d.z;
+
+                if (d0 >= 0.0D) {
+                    ++d6;
+                }
+
+                if (d1 >= 0.0D) {
+                    ++d7;
+                }
+
+                d6 /= d0;
+                d7 /= d1;
+                int j1 = d0 < 0.0D ? -1 : 1;
+                int k1 = d1 < 0.0D ? -1 : 1;
+                int l1 = MathHelper.floor(vec3d1.x);
+                int i2 = MathHelper.floor(vec3d1.z);
+                int j2 = l1 - l;
+                int k2 = i2 - i1;
+
+                do {
+                    if (j2 * j1 <= 0 && k2 * k1 <= 0) {
+                        return true;
+                    }
+
+                    if (d6 < d7) {
+                        d6 += d4;
+                        l += j1;
+                        j2 = l1 - l;
+                    } else {
+                        d7 += d5;
+                        i1 += k1;
+                        k2 = i2 - i1;
+                    }
+                } while (this.a(l, (int) vec3d.y, i1, i, j, k, vec3d, d0, d1));
+
+                return false;
+            }
+        }
+    }
+
+    private boolean a(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        int k1 = i - l / 2;
+        int l1 = k - j1 / 2;
+
+        if (!this.b(k1, j, l1, l, i1, j1, vec3d, d0, d1)) {
+            return false;
+        } else {
+            for (int i2 = k1; i2 < k1 + l; ++i2) {
+                for (int j2 = l1; j2 < l1 + j1; ++j2) {
+                    double d2 = (double) i2 + 0.5D - vec3d.x;
+                    double d3 = (double) j2 + 0.5D - vec3d.z;
+
+                    if (d2 * d0 + d3 * d1 >= 0.0D) {
+                        PathType pathtype = this.e.a(this.b, i2, j - 1, j2, this.a, l, i1, j1, true, true);
+
+                        if (pathtype == PathType.WATER) {
+                            return false;
+                        }
+
+                        if (pathtype == PathType.LAVA) {
+                            return false;
+                        }
+
+                        if (pathtype == PathType.OPEN) {
+                            return false;
+                        }
+
+                        pathtype = this.e.a(this.b, i2, j, j2, this.a, l, i1, j1, true, true);
+                        float f = this.a.a(pathtype);
+
+                        if (f < 0.0F || f >= 8.0F) {
+                            return false;
+                        }
+
+                        if (pathtype == PathType.DAMAGE_FIRE || pathtype == PathType.DANGER_FIRE || pathtype == PathType.DAMAGE_OTHER) {
+                            return false;
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+
+    private boolean b(int i, int j, int k, int l, int i1, int j1, Vec3D vec3d, double d0, double d1) {
+        Iterator iterator = BlockPosition.a(new BlockPosition(i, j, k), new BlockPosition(i + l - 1, j + i1 - 1, k + j1 - 1)).iterator();
+
+        while (iterator.hasNext()) {
+            BlockPosition blockposition = (BlockPosition) iterator.next();
+            double d2 = (double) blockposition.getX() + 0.5D - vec3d.x;
+            double d3 = (double) blockposition.getZ() + 0.5D - vec3d.z;
+
+            if (d2 * d0 + d3 * d1 >= 0.0D) {
+                Block block = this.b.getType(blockposition).getBlock();
+
+                if (!block.b(this.b, blockposition)) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public void a(boolean flag) {
+        this.e.b(flag);
+    }
+
+    public void b(boolean flag) {
+        this.e.a(flag);
+    }
+
+    public boolean f() {
+        return this.e.c();
+    }
+
+    public void c(boolean flag) {
+        this.e.c(flag);
+    }
+
+    public boolean g() {
+        return this.e.e();
+    }
+
+    public void d(boolean flag) {
+        this.f = flag;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NavigationListener.java src/main/java/net/minecraft/server/NavigationListener.java
--- src_origin/main/java/net/minecraft/server/NavigationListener.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationListener.java	2017-05-30 05:34:08.915665524 +0800
@@ -0,0 +1,80 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import java.util.List;
+import java.util.Queue;
+import javax.annotation.Nullable;
+
+public class NavigationListener implements IWorldAccess {
+
+    //private final List<NavigationAbstract> a = Lists.newArrayList();
+    private final Queue<NavigationAbstract> a = Queues.newConcurrentLinkedQueue();//hose
+
+    public NavigationListener() {}
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
+        if (this.a(world, blockposition, iblockdata, iblockdata1)) {
+            int j = 0;
+
+            //for (int k = this.a.size(); j < k; ++j) {
+            for (NavigationAbstract navigationabstract: this.a) {//hose
+                //NavigationAbstract navigationabstract = (NavigationAbstract) this.a.get(j);
+
+                if (navigationabstract != null && !navigationabstract.i()) {
+                    PathEntity pathentity = navigationabstract.k();
+
+                    if (pathentity != null && !pathentity.b() && pathentity.d() != 0) {
+                        PathPoint pathpoint = navigationabstract.c.c();
+                        double d0 = blockposition.distanceSquared(((double) pathpoint.a + navigationabstract.a.locX) / 2.0D, ((double) pathpoint.b + navigationabstract.a.locY) / 2.0D, ((double) pathpoint.c + navigationabstract.a.locZ) / 2.0D);
+                        int l = (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e());
+
+                        if (d0 < (double) l) {
+                            navigationabstract.j();
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected boolean a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        AxisAlignedBB axisalignedbb = iblockdata.c(world, blockposition);
+        AxisAlignedBB axisalignedbb1 = iblockdata1.c(world, blockposition);
+
+        return axisalignedbb != axisalignedbb1 && (axisalignedbb == null || !axisalignedbb.equals(axisalignedbb1));
+    }
+
+    public void a(BlockPosition blockposition) {}
+
+    public void a(int i, int j, int k, int l, int i1, int j1) {}
+
+    public void a(@Nullable EntityHuman entityhuman, SoundEffect soundeffect, SoundCategory soundcategory, double d0, double d1, double d2, float f, float f1) {}
+
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {}
+
+    public void a(int i, boolean flag, boolean flag1, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {}
+
+    public void a(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.add(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void b(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.remove(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void a(SoundEffect soundeffect, BlockPosition blockposition) {}
+
+    public void a(int i, BlockPosition blockposition, int j) {}
+
+    public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {}
+
+    public void b(int i, BlockPosition blockposition, int j) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2017-05-30 05:34:09.132665544 +0800
@@ -0,0 +1,273 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import javax.annotation.Nullable;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    //private final List<BlockPosition> c = Lists.newArrayList();
+    private final Queue<BlockPosition> c = Queues.newConcurrentLinkedQueue();//hose    
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            //this.b((BlockPosition) this.c.remove(0));
+            this.b((BlockPosition) this.c.poll());//hose
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2017-05-15 13:09:53.595961699 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2017-05-30 05:34:09.146665545 +0800
@@ -42,7 +42,8 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();//hose
     private final List<PlayerChunk> g = Lists.newLinkedList();
     private final List<PlayerChunk> h = Lists.newLinkedList();
     private final List<PlayerChunk> i = Lists.newArrayList();
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2017-05-15 13:09:53.649961704 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2017-05-30 05:34:09.207665551 +0800
@@ -432,7 +432,8 @@
         // CraftBukkit end
 
         ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
-
+        //untrack player
+        entityplayer.x().getTracker().untrackPlayer(entityplayer);
         return playerQuitEvent.getQuitMessage(); // CraftBukkit
     }
 
@@ -996,9 +997,12 @@
     }
 
     public void sendAll(Packet packet, World world) {
+        world.players.stream().forEach(pl -> ((EntityPlayer) pl).playerConnection.sendPacket(packet));
+        
+        /*
         for (int i = 0; i < world.players.size(); ++i) {
             ((EntityPlayer) world.players.get(i)).playerConnection.sendPacket(packet);
-        }
+        }*/
 
     }
     // CraftBukkit end
diff -Naur src_origin/main/java/net/minecraft/server/RegionFileCache.java src/main/java/net/minecraft/server/RegionFileCache.java
--- src_origin/main/java/net/minecraft/server/RegionFileCache.java	2017-05-15 13:09:53.717961710 +0800
+++ src/main/java/net/minecraft/server/RegionFileCache.java	2017-05-30 05:34:09.279665558 +0800
@@ -10,7 +10,8 @@
 
 public class RegionFileCache {
 
-    public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    //public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    public static final Map<File, RegionFile> a = Maps.newConcurrentMap();
 
     public static synchronized RegionFile a(File file, int i, int j) {
         File file1 = new File(file, "region");
@@ -47,6 +48,7 @@
                 a();
             }
 
+            //use callable
             RegionFile regionfile1 = new RegionFile(file2);
 
             RegionFileCache.a.put(file2, regionfile1);
diff -Naur src_origin/main/java/net/minecraft/server/VillageSiege.java src/main/java/net/minecraft/server/VillageSiege.java
--- src_origin/main/java/net/minecraft/server/VillageSiege.java	2017-05-15 13:09:53.865961724 +0800
+++ src/main/java/net/minecraft/server/VillageSiege.java	2017-05-30 05:34:09.456665574 +0800
@@ -64,6 +64,58 @@
     }
 
     private boolean b() {
+        for (EntityHuman entityhuman:this.a.players) {
+            if (!entityhuman.isSpectator()) {
+                this.f = this.a.ai().getClosestVillage(new BlockPosition(entityhuman), 1);
+                if (this.f != null && this.f.c() >= 10 && this.f.d() >= 20 && this.f.e() >= 20) {
+                    BlockPosition blockposition = this.f.a();
+                    float f = (float) this.f.b();
+                    boolean flag = false;
+                    int i = 0;
+
+                    while (true) {
+                        if (i < 10) {
+                            float f1 = this.a.random.nextFloat() * 6.2831855F;
+
+                            this.g = blockposition.getX() + (int) ((double) (MathHelper.cos(f1) * f) * 0.9D);
+                            this.h = blockposition.getY();
+                            this.i = blockposition.getZ() + (int) ((double) (MathHelper.sin(f1) * f) * 0.9D);
+                            flag = false;
+                            Iterator iterator1 = this.a.ai().getVillages().iterator();
+
+                            while (iterator1.hasNext()) {
+                                Village village = (Village) iterator1.next();
+
+                                if (village != this.f && village.a(new BlockPosition(this.g, this.h, this.i))) {
+                                    flag = true;
+                                    break;
+                                }
+                            }
+
+                            if (flag) {
+                                ++i;
+                                continue;
+                            }
+                        }
+
+                        if (flag) {
+                            return false;
+                        }
+
+                        Vec3D vec3d = this.a(new BlockPosition(this.g, this.h, this.i));
+
+                        if (vec3d != null) {
+                            this.e = 0;
+                            this.d = 20;
+                            return true;
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+        
+        /*
         List list = this.a.players;
         Iterator iterator = list.iterator();
 
@@ -118,7 +170,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         return false;
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldData.java src/main/java/net/minecraft/server/WorldData.java
--- src_origin/main/java/net/minecraft/server/WorldData.java	2017-05-15 13:09:53.902961727 +0800
+++ src/main/java/net/minecraft/server/WorldData.java	2017-05-30 05:34:09.491665578 +0800
@@ -630,7 +630,8 @@
         this.C = enumdifficulty;
         // CraftBukkit start
         PacketPlayOutServerDifficulty packet = new PacketPlayOutServerDifficulty(this.getDifficulty(), this.isDifficultyLocked());
-        for (EntityPlayer player : (java.util.List<EntityPlayer>) (java.util.List) world.players) {
+        //for (EntityPlayer player : (java.util.List<EntityPlayer>) (java.util.List) world.players) {
+        for (EntityPlayer player : (java.util.Queue<EntityPlayer>) (java.util.Queue) world.players) {
             player.playerConnection.sendPacket(packet);
         }
         // CraftBukkit end
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2017-05-15 13:09:53.897961727 +0800
+++ src/main/java/net/minecraft/server/World.java	2017-05-30 05:34:09.503665579 +0800
@@ -15,7 +15,9 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -34,6 +36,9 @@
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
+    public final Queue<Entity> entityList = Queues.newConcurrentLinkedQueue();//hose
+    public final Queue<Entity> entityList_remove = Queues.newConcurrentLinkedQueue();//hose
+    /*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
@@ -57,16 +62,19 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
-    private final List<TileEntity> b = Lists.newArrayList();
+    //private final List<TileEntity> b = Lists.newArrayList();
+    private final Queue<TileEntity> b = Queues.newConcurrentLinkedQueue();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
-    public final List<EntityHuman> players = Lists.newArrayList();
+    //public final List<EntityHuman> players = Lists.newArrayList();
+    public final Queue<EntityHuman> players = Queues.newConcurrentLinkedQueue();//hose
     public final List<Entity> j = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final Map<Integer, Entity> entitiesById = Maps.newConcurrentMap();//hose
     private final long I = 16777215L;
     private int J;
     protected int l = (new Random()).nextInt();
@@ -333,7 +341,7 @@
         return this.isChunkLoaded(i, j, false) ? true : this.chunkProvider.e(i, j);
     }
 
-    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
+    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {//hose
         // CraftBukkit start - tree generation
         if (this.captureTreeGeneration) {
             BlockState blockstate = null;
@@ -1155,13 +1163,15 @@
         }
 
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        /*
         int index = this.entityList.indexOf(entity);
         if (index != -1) {
             if (index <= this.tickPosition) {
                 this.tickPosition--;
             }
             this.entityList.remove(index);
-        }
+        }*/
+        this.entityList.remove(entity);
         // CraftBukkit end
         } // Spigot
         this.c(entity);
@@ -1341,6 +1351,9 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
+    CrashReportSystemDetails crashreportsystemdetails1;//hose
+    CrashReport crashreport1;
+    //public final Queue<Entity> entityList_remove = Queues.newConcurrentLinkedQueue();
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
@@ -1383,12 +1396,16 @@
         int j;
 
         for (i = 0; i < this.f.size(); ++i) {
-            entity = (Entity) this.f.get(i);
-            int k = entity.ab;
+            try {
+                entity = (Entity) this.f.get(i);
+                int k = entity.ab;
 
-            j = entity.ad;
-            if (entity.aa && this.isChunkLoaded(k, j, true)) {
-                this.getChunkAt(k, j).b(entity);
+                j = entity.ad;
+                if (entity.aa && this.isChunkLoaded(k, j, true)) {
+                    this.getChunkAt(k, j).b(entity);
+                }
+            } catch (Exception ex) {
+                
             }
         }
 
@@ -1400,8 +1417,8 @@
         this.l();
         this.methodProfiler.c("regular");
 
-        CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        //CrashReportSystemDetails crashreportsystemdetails1;
+        //CrashReport crashreport1;
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
@@ -1409,38 +1426,105 @@
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
-        for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
-            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
-            // CraftBukkit end
-            Entity entity1 = entity.bB();
+        
+        
+        entityLimiter.initTick();//hose
+        entityList.parallelStream().forEach(ent -> {//hose
+            if (!entityLimiter.shouldContinue()) {
+                return;
+            }
+            
+            Entity entity1 = ent.bB();
 
             if (entity1 != null) {
-                if (!entity1.dead && entity1.w(entity)) {
-                    continue;
+                if (!entity1.dead && entity1.w(ent)) {
+                    return;
                 }
 
-                entity.stopRiding();
+                ent.stopRiding();
             }
 
             this.methodProfiler.a("tick");
-            if (!entity.dead && !(entity instanceof EntityPlayer)) {
+            if (!ent.dead && !(ent instanceof EntityPlayer)) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.h(entity);
+                    this.h(ent);
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport1 = CrashReport.a(throwable1, "Ticking entity");
                     crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
-                    entity.appendEntityCrashDetails(crashreportsystemdetails1);
+                    ent.appendEntityCrashDetails(crashreportsystemdetails1);
                     throw new ReportedException(crashreport1);
                 }
             }
 
             this.methodProfiler.b();
             this.methodProfiler.a("remove");
+            if (ent.dead) {
+                int jj = ent.ab;
+                int l = ent.ad;
+
+                if (ent.aa && this.isChunkLoaded(jj, l, true)) {
+                    this.getChunkAt(jj, l).b(ent);
+                }
+
+                //guardEntityList = false; // Spigot
+                //this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                //this.entityList.remove(ent);
+                entityList_remove.add(ent);
+                //guardEntityList = true; // Spigot
+                this.c(ent);
+            }
+
+            this.methodProfiler.b();
+        });
+        this.entityList.removeAll(entityList_remove);
+        entityList_remove.clear();
+        /*
+        for (entityLimiter.initTick();
+                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
+                tickPosition++, entitiesThisCycle++) {
+            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+            try {
+                entity = (Entity) this.entityList.get(this.tickPosition);
+            } catch (Exception ex) {
+                continue;
+            } 
+            // CraftBukkit end
+            Entity entity1 = null;
+            try {
+                entity1 = entity.bB();
+            } catch (Exception ex) {
+                entity1 = null;
+            }
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(entity)) {
+                    continue;
+                }
+
+                entity.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            try {
+                if (!entity.dead && !(entity instanceof EntityPlayer)) {
+                    try {
+                        SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                        this.h(entity);
+                        SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                    } catch (Throwable throwable1) {
+                        crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                        crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                        entity.appendEntityCrashDetails(crashreportsystemdetails1);
+                        throw new ReportedException(crashreport1);
+                    }
+                }
+            } catch (Exception ex) {
+                continue;
+            } 
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
             if (entity.dead) {
                 j = entity.ab;
                 int l = entity.ad;
@@ -1456,7 +1540,7 @@
             }
 
             this.methodProfiler.b();
-        }
+        }*/
         guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
@@ -1534,16 +1618,26 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
+            
+            this.b.stream().filter(tileentity1 -> !tileentity1.y()).filter(tileentity1 -> this.isLoaded(tileentity1.getPosition())).forEach(tileentity1 -> {
+                Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
+                IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
+
+                chunk.a(tileentity1.getPosition(), tileentity1);
+                this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
+                // CraftBukkit start
+                // From above, don't screw this up - SPIGOT-1746
+                if (!this.tileEntityList.contains(tileentity1)) {
+                    this.a(tileentity1);
+                }
+                // CraftBukkit end
+            });
+            /*
             for (int i1 = 0; i1 < this.b.size(); ++i1) {
                 TileEntity tileentity1 = (TileEntity) this.b.get(i1);
 
                 if (!tileentity1.y()) {
-                    /* CraftBukkit start - Order matters, moved down
-                    if (!this.tileEntityList.contains(tileentity1)) {
-                        this.a(tileentity1);
-                    }
-                    // CraftBukkit end */
-
+                    
                     if (this.isLoaded(tileentity1.getPosition())) {
                         Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
                         IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
@@ -1558,7 +1652,7 @@
                         // CraftBukkit end
                     }
                 }
-            }
+            }*/
 
             this.b.clear();
         }
@@ -1672,6 +1766,15 @@
 
             this.methodProfiler.b();
             if (flag && entity.aa) {
+                
+                entity.bx().forEach(entity1 -> {//hose
+                    if (!entity1.dead && entity1.bB() == entity) {
+                        this.h(entity1);
+                    } else {
+                        entity1.stopRiding();
+                    }
+                });
+                /*
                 Iterator iterator = entity.bx().iterator();
 
                 while (iterator.hasNext()) {
@@ -1682,7 +1785,7 @@
                     } else {
                         entity1.stopRiding();
                     }
-                }
+                }*/
             }
 
             entity.tickTimer.stopTiming(); // Spigot
@@ -1955,13 +2058,19 @@
 
     @Nullable
     private TileEntity F(BlockPosition blockposition) {
+        for (TileEntity tileentity: this.b) {
+            if (!tileentity.y() && tileentity.getPosition().equals(blockposition)) {
+                return tileentity;
+            }
+        }
+        /*
         for (int i = 0; i < this.b.size(); ++i) {
             TileEntity tileentity = (TileEntity) this.b.get(i);
 
             if (!tileentity.y() && tileentity.getPosition().equals(blockposition)) {
                 return tileentity;
             }
-        }
+        }*/
 
         return null;
     }
@@ -2139,11 +2248,13 @@
                 this.o = MathHelper.a(this.o, 0.0F, 1.0F);
 
                 // CraftBukkit start
+                this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pltw -> ((EntityPlayer) pltw).tickWeather());//hose
+                /*
                 for (int idx = 0; idx < this.players.size(); ++idx) {
                     if (((EntityPlayer) this.players.get(idx)).world == this) {
                         ((EntityPlayer) this.players.get(idx)).tickWeather();
                     }
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -2689,7 +2800,23 @@
     public EntityHuman a(double d0, double d1, double d2, double d3, Predicate<Entity> predicate) {
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
+        
+        for (EntityHuman entityhuman1: this.players) {//hose
+            if (entityhuman1 == null || entityhuman1.dead) {
+                continue;
+            }
+            // CraftBukkit end
 
+            if (predicate.apply(entityhuman1)) {
+                double d5 = entityhuman1.d(d0, d1, d2);
+ 
+                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
+                    d4 = d5;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
             // CraftBukkit start - Fixed an NPE
@@ -2706,12 +2833,14 @@
                     entityhuman = entityhuman1;
                 }
             }
-        }
+        }*/
 
         return entityhuman;
     }
 
     public boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        return this.players.stream().filter((entityhuman) -> (IEntitySelector.e.apply(entityhuman))).map((entityhuman) -> entityhuman.d(d0, d1, d2)).anyMatch((d4) -> (d3 < 0.0D || d4 < d3 * d3));//hose
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
@@ -2724,7 +2853,7 @@
             }
         }
 
-        return false;
+        return false;*/
     }
 
     @Nullable
@@ -2741,7 +2870,37 @@
     public EntityHuman a(double d0, double d1, double d2, double d3, double d4, @Nullable Function<EntityHuman, Double> function, @Nullable Predicate<EntityHuman> predicate) {
         double d5 = -1.0D;
         EntityHuman entityhuman = null;
+        
+       for (EntityHuman entityhuman1: this.players) {//hose
+            if (!entityhuman1.abilities.isInvulnerable && entityhuman1.isAlive() && !entityhuman1.isSpectator() && (predicate == null || predicate.apply(entityhuman1))) {
+                double d6 = entityhuman1.d(d0, entityhuman1.locY, d2);
+                double d7 = d3;
+
+                if (entityhuman1.isSneaking()) {
+                    d7 = d3 * 0.800000011920929D;
+                }
 
+                if (entityhuman1.isInvisible()) {
+                    float f = entityhuman1.cO();
+
+                    if (f < 0.1F) {
+                        f = 0.1F;
+                    }
+
+                    d7 *= (double) (0.7F * f);
+                }
+
+                if (function != null) {
+                    d7 *= ((Double) Objects.firstNonNull(function.apply(entityhuman1), Double.valueOf(1.0D))).doubleValue();
+                }
+
+                if ((d4 < 0.0D || Math.abs(entityhuman1.locY - d1) < d4 * d4) && (d3 < 0.0D || d6 < d7 * d7) && (d5 == -1.0D || d6 < d5)) {
+                    d5 = d6;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
 
@@ -2772,33 +2931,45 @@
                     entityhuman = entityhuman1;
                 }
             }
-        }
+        }*/
 
         return entityhuman;
     }
 
     @Nullable
     public EntityHuman a(String s) {
+        for (EntityHuman entityhuman: this.players) {//hose
+            if (s.equals(entityhuman.getName())) {
+                return entityhuman;
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
             if (s.equals(entityhuman.getName())) {
                 return entityhuman;
             }
-        }
+        }*/
 
         return null;
     }
 
     @Nullable
     public EntityHuman b(UUID uuid) {
+        for (EntityHuman entityhuman: this.players) {//hose
+            if (uuid.equals(entityhuman.getUniqueID())) {
+                return entityhuman;
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
             if (uuid.equals(entityhuman.getUniqueID())) {
                 return entityhuman;
             }
-        }
+        }*/
 
         return null;
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2017-05-15 13:09:53.994961736 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2017-05-30 05:34:09.599665588 +0800
@@ -3,6 +3,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.File;
@@ -11,10 +12,16 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -29,6 +36,7 @@
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.spigotmc.TickLimiter;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -39,7 +47,8 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
     private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    //private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = Maps.newConcurrentMap();//hose
     public boolean savingDisabled;
     private boolean O;
     private int emptyTime;
@@ -48,7 +57,8 @@
     protected final VillageSiege siegeManager = new VillageSiege(this);
     private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private final List<NextTickListEntry> U = Lists.newArrayList();
+    //private final List<NextTickListEntry> U = Lists.newArrayList();
+    private final Queue<NextTickListEntry> U = Queues.newConcurrentLinkedQueue();
 
     // CraftBukkit start
     public final int dimension;
@@ -203,7 +213,7 @@
         }
     }
     // CraftBukkit end
-
+    
     public void doTick() {
         super.doTick();
         if (this.getWorldData().isHardcore() && this.getDifficulty() != EnumDifficulty.HARD) {
@@ -226,7 +236,12 @@
         long time = this.worldData.getTime();
         if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
             timings.mobSpawn.startTiming(); // Spigot
-            this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            //this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            boolean flag = this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L);//hose
+            boolean flag1 = this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L);//hose
+            boolean flag2 = this.worldData.getTime() % 400L == 0L;//hose
+            spawnerCreature sc = new spawnerCreature(this, flag, flag1, flag2);//hose
+            sc.fork();//hose
             timings.mobSpawn.stopTiming(); // Spigot
             // CraftBukkit end
         }
@@ -257,6 +272,8 @@
         this.methodProfiler.c("chunkMap");
         timings.doChunkMap.startTiming(); // Spigot
         this.manager.flush();
+        /*cmf cmft = new cmf(this.manager);
+        cmft.fork();*/
         timings.doChunkMap.stopTiming(); // Spigot
         this.methodProfiler.c("village");
         timings.doVillages.startTiming(); // Spigot
@@ -386,12 +403,16 @@
         this.methodProfiler.a("playerCheckLight");
         if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             int i = this.random.nextInt(this.players.size());
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            //EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            ArrayList rndarr = new ArrayList(this.players);//hose
+            EntityHuman entityhuman = (EntityHuman) rndarr.get(i);
             int j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
             int k = MathHelper.floor(entityhuman.locY) + this.random.nextInt(11) - 5;
             int l = MathHelper.floor(entityhuman.locZ) + this.random.nextInt(11) - 5;
 
-            this.w(new BlockPosition(j, k, l));
+            //this.w(new BlockPosition(j, k, l));
+            clight cl = new clight(j, k, l);//hose
+            cl.fork();
         }
 
         this.methodProfiler.b();
@@ -623,8 +644,9 @@
         super.l();
         this.methodProfiler.c("players");
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            Entity entity = (Entity) this.players.get(i);
+        //for (int i = 0; i < this.players.size(); ++i) {
+        for (Entity entity: this.players) {//hose
+            //Entity entity = (Entity) this.players.get(i);
             Entity entity1 = entity.bB();
 
             if (entity1 != null) {
@@ -670,7 +692,8 @@
     public void m() {
         this.emptyTime = 0;
     }
-
+    
+    private TickLimiter pendingLimiter = new TickLimiter(10);
     public boolean a(boolean flag) {
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -693,9 +716,12 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
+                //System.out.println(nextTickList.size());
                 for (int j = 0; j < i; ++j) {
                     nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    if (nextticklistentry == null) {
+                        break;
+                    }
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -709,8 +735,12 @@
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
                 Iterator iterator = this.U.iterator();
-
+                //long tickst = System.currentTimeMillis();
+                pendingLimiter.initTick();
                 while (iterator.hasNext()) {
+                    if (!pendingLimiter.shouldContinue()) {
+                        break;
+                    }
                     nextticklistentry = (NextTickListEntry) iterator.next();
                     iterator.remove();
                     boolean flag1 = false;
@@ -733,9 +763,9 @@
                         this.a(nextticklistentry.a, nextticklistentry.a(), 0);
                     }
                 }
-
+                //long ticket = System.currentTimeMillis();
                 this.methodProfiler.b();
-                this.U.clear();
+                //this.U.clear();
                 return !this.nextTickList.isEmpty();
             }
         }
@@ -1068,6 +1098,12 @@
 
     public void a(Collection<Entity> collection) {
         ArrayList arraylist = Lists.newArrayList(collection);
+        
+        arraylist.stream().filter(entity -> this.j((Entity)entity)).forEach(entity -> {//hose
+            this.entityList.add((Entity)entity);
+            this.b((Entity)entity);
+        });
+        /*
         Iterator iterator = arraylist.iterator();
 
         while (iterator.hasNext()) {
@@ -1077,7 +1113,7 @@
                 this.entityList.add(entity);
                 this.b(entity);
             }
-        }
+        }*/
 
     }
 
@@ -1111,7 +1147,8 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(entity.getId(), entity);//hose
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aT();
 
@@ -1122,7 +1159,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.a(entity1.getId(), entity1);
+                //this.entitiesById.a(entity1.getId(), entity1);
+                this.entitiesById.put(entity1.getId(), entity1);//hose
             }
         }
 
@@ -1130,7 +1168,8 @@
 
     protected void c(Entity entity) {
         super.c(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        this.entitiesById.remove(entity.getId());//hose
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aT();
 
@@ -1141,7 +1180,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.d(entity1.getId());
+                //this.entitiesById.d(entity1.getId());
+                this.entitiesById.remove(entity1.getId());//hose
             }
         }
 
@@ -1278,17 +1318,20 @@
         // */
         if (flag != this.W()) {
             // Only send weather packets to those affected
-            for (int i = 0; i < this.players.size(); ++i) {
+            this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pl -> ((EntityPlayer) pl).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false));//hose
+            /*for (int i = 0; i < this.players.size(); ++i) {
                 if (((EntityPlayer) this.players.get(i)).world == this) {
                     ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
                 }
-            }
+            }*/
         }
+        this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pl -> ((EntityPlayer) pl).updateWeather(this.n, this.o, this.p, this.q));//hose
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             if (((EntityPlayer) this.players.get(i)).world == this) {
                 ((EntityPlayer) this.players.get(i)).updateWeather(this.n, this.o, this.p, this.q);
             }
-        }
+        }*/
         // CraftBukkit end
 
     }
@@ -1326,7 +1369,16 @@
     public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
         // CraftBukkit end
         PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
+        
+        for (EntityHuman entityplayer: this.players){//hose
+            if (sender != null && !((EntityPlayer)entityplayer).getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+            BlockPosition blockposition = ((EntityPlayer)entityplayer).getChunkCoordinates();
+            double d7 = blockposition.distanceSquared(d0, d1, d2);
+
 
+            this.a((EntityPlayer)entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
+        }
+        /*
         for (int j = 0; j < this.players.size(); ++j) {
             EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
             if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
@@ -1335,7 +1387,7 @@
 
 
             this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
-        }
+        }*/
 
     }
 
@@ -1385,4 +1437,71 @@
             this();
         }
     }
+    
+    public class spawnerCreature extends RecursiveAction {
+        WorldServer worldserver;
+        boolean flag, flag1, flag2;
+        
+        public spawnerCreature(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+            this.worldserver = worldserver;
+            this.flag = flag;
+            this.flag1 = flag1;
+            this.flag2 = flag2;
+        }
+        
+        @Override
+        protected void compute() {
+            spawnerCreature.a(worldserver, flag, flag1, flag2);
+        }
+        
+    }
+    
+    public class cmf extends RecursiveAction {
+        PlayerChunkMap manager;
+        
+        public cmf(PlayerChunkMap manager) {
+            this.manager = manager;
+        }
+        
+        @Override
+        protected void compute() {
+            this.manager.flush();
+        }
+        
+    }
+    
+    public class clight extends RecursiveAction {
+        int j, k, l;
+        
+        public clight(int j, int k, int l) {
+            this.l = l;
+            this.j = j;
+            this.k = k;
+        }
+        
+        @Override
+        protected void compute() {
+            try {
+                w(new BlockPosition(this.j, this.k, this.l));
+            } catch (Exception ex) {
+                LogManager.getLogger().warn("check light warn: "+ex);
+            }
+        }
+        
+    }
+    
+    
+    public class doSound extends RecursiveAction {
+        
+        @Override
+        protected void compute() {
+            try {
+                ao();
+            } catch (Exception ex) {
+                LogManager.getLogger().warn("do sound: "+ex);
+            }
+        }
+        
+    }
+    
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
--- src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java	2017-05-15 13:09:54.913961822 +0800
+++ src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java	2017-05-30 05:34:10.548665676 +0800
@@ -8,6 +8,7 @@
 
 public class ChunkIOExecutor {
     static final int BASE_THREADS = 1;
+    static final int NOW_THREADS = 1;
     static final int PLAYERS_PER_THREAD = 50;
 
     private static final AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException> instance = new AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException>(new ChunkIOProvider(), BASE_THREADS);
@@ -27,7 +28,9 @@
 
     public static void adjustPoolSize(int players) {
         int size = Math.max(BASE_THREADS, (int) Math.ceil(players / PLAYERS_PER_THREAD));
-        instance.setActiveThreads(size);
+        if (size != NOW_THREADS) {
+            instance.setActiveThreads(size);
+        }
     }
 
     public static void tick() {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2017-05-15 13:09:55.835961908 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2017-05-30 05:34:11.578665773 +0800
@@ -500,6 +500,18 @@
                 cause = DamageCause.CONTACT;
             } else if (source == DamageSource.HOT_FLOOR) {
                 cause = DamageCause.HOT_FLOOR;
+            } else if (source == DamageSource.CRAMMING) {//hose
+                cause = DamageCause.CRAMMING;
+            } else if (source == DamageSource.DROWN) {//hose
+                cause = DamageCause.DROWNING;
+            } else if (source == DamageSource.FALL) {//hose
+                cause = DamageCause.FALL;
+            } else if (source == DamageSource.STUCK) {//hose
+                cause = DamageCause.SUFFOCATION;
+            } else if (source == DamageSource.FIRE) {//hose
+                cause = DamageCause.FIRE;             
+            } else if (source == DamageSource.BURN) {//hose
+                cause = DamageCause.FIRE_TICK;                             
             } else {
                 throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
             }
@@ -557,8 +569,12 @@
             cause = DamageCause.CRAMMING;
         } else if (source == DamageSource.GENERIC) {
             cause = DamageCause.CUSTOM;
+        } else if (source == DamageSource.CACTUS) {//hose
+            cause = DamageCause.CONTACT;
+        } else if (source == DamageSource.HOT_FLOOR) {//hose
+            cause = DamageCause.HOT_FLOOR;
         }
-
+        
         if (cause != null) {
             return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
         }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2017-05-15 13:09:56.791961998 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2017-05-30 05:34:12.587665867 +0800
@@ -1,15 +1,19 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();//hose
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet();//hose
 
     public HashTreeSet() {
 
@@ -110,8 +114,20 @@
         tree.clear();
     }
 
-    public V first() {
-        return tree.first();
+    public V first() {//hose
+        if (tree.size() > 0) {
+            return tree.first();
+        }
+        return null;
     }
 
+    public V pollfirst() {//hose
+        if (tree.size() > 0) {
+            V v = tree.first();
+            hash.remove(v);
+            tree.remove(v);
+            return v;
+        }
+        return null;
+    }
 }
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2017-05-15 13:09:51.314961485 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2017-05-30 05:34:06.694665316 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )//hose
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2017-05-15 13:09:51.314961485 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2017-05-30 05:34:06.686665315 +0800
@@ -11,7 +11,7 @@
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+            //throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
 }
